### MIPS [aside]
- a reduced instruction set computer (RISC) instruction set architecture (ISA)
- MIPS implementations are primarily used in embedded systems
- tries to avoid the use of stacks (because of speed)
  - MIPS reserves four registers to pass arguments `$a0` ... 3
  - passing arguments that cannot be contained in 4 registers use the stack
  - however, nested functions still require the use of the stack
- this kind of architecture is advantageous for leaf procedures, where there are no nested function calls 
  
### Abstraction: labels & variables
- an **opcode** is a word that represents a machine language instruction (ADD, JR ... )
- **assembly language** is a lang for writing machine lang programs using opcodes instead of bits
- **assembler** is a program that translates assembly lang. into machine lang.
- **label** is an abstraction of a memory address (think variable assignment)
- instructions are words (strings of bits)
- a **code** can be a word for instructions or extra features like labels, that are not instructions
- to eliminate labels, first pass build a symbol table, a map from labels to addresses. second pass converts each use of label to address/offset
```sh
Find abs value of $1 (two's complement)
SLT(2,1,0)
beq(2, 0, label) # beq takes labels while BEQ takes offsets
SUB(1, 0, 1)
Define(label)
JR(31) # end the program
```

### Relocation and Linking
- def: an *object file* contains machine language code with additional metadata, which records how labels were used before translation to machine lang (which addresses need to be offset)
- def: *relocation* is the process of adjusting addresses in machine lang code so it can be loaded at different memory addresses
  - conceptually, it reverse engineering what the assembly code would have been, then it reassembled at some offset, loaded at a different memory address
- def: *linking* is the process of combining object files into one (object file, program, library)
  - to link, relocate conflicting object files and labels based on metadata
- Typical c compilation process: `.c` compiles to assembly `.s`, assemble to object files `.o` , then link object files to an executable program

Stack, `$30` stores the stack pointer, pointing to the top of the stack
- to access variables, you need an offsest from the stack pointer
- a symbol table maps variables to offsets
- a *frame pointer* at `$29` is a copy of the stack pointer made at the beginning of a procedure that stays constant for the *duration of the procedure call*, this is used as the origin of offset for accessing variables in the current stack frame. This allows the actual stack pointer to change without ruining our symbol table

- *variables* are abstractions of storage locations that hold a value
- the *extent* or lifetime of a variable instance is the time interval in which the variable can be accessed
  - local vars have the extent of execution of procedure, global have extent of entire program, fields of objects have extent of time until object is freed (explicitly or by GC)
  - variables are stored at offests relative to the frame pointer
- Symbol table holds the offset of each variable 
  - translation time/compile time is when you tkae high level program with variables and translate to machine code. Symbol table is used here to replace variables with their respective address
  - at compile time, to access variable, `LW(3,8,29)` loads into R3, from an offset of 8 to the frame pointer
- on the stack, allocate chunk of consecutive memory locations rather than single bytes. Each chunk has 2 reserved words of memory: first is size, second is reserved by convention
  - in assignments, allocate all memory in chunks

### Evaluating Expressions
1. Using the stack:
- for `(e1 op e2)`, build a binary expression tree, generate code to evaluate `e1` and `e2`
- store intermediate responses on the stack
- conceptually simple, but verbose
```
evaluate(e1, op, e2)
  evaluate(e1)
  push $3 onto stack
  evaluate(e2)
  pop from stack $4
  $3 = $4 pop $3
```

2. Using temp vars/virtual registers:
- flexible but still generates lots of variables unnecessarily
```scala
evaluate(e1, op, e2):(Code, Variable) = {
  val (c1, v1) = evaluate(e1)
  val (c1, v1) = evaluate(e2)
  val result = new Variable
  val code = block(c1,c2,"result = v1 op v2")
  (code, result)
}
```
- **register allocation** is the process of assigning virtual register (Variables) to real registers or memory locations
  - minimize number of real registers/stack locations by sharing them among non-interfering virtual registers
  - intermediate representation with virtual registers => register allocation => intermediate representation with real registers and stack locations 
 
 3. Using temp vars with operations on registers
- same as first, but adds abstraction with lends to more efficient underlying implementation
```
evaluate(e1 op e2) {
  withTempVar {
    block(
     evaluate(e1)
     write(t1,$3)
     evaluate(e2)
     read($4, t1)
     $3 = $4 op $3
    )
  }
}
```

If statements:
```
if (e1 op e2) T else E

evaluate(e1)
t1 = $3
evaluate(e2)
$4 = t1
comparison of $4 and $3, branch to labelElse
T
jump to labelEnd
Define(labelElse)
  E
Define(labelEnd)
```
