What differentiates a register vs an address

### Intro to Addressing
- binary prefixes, 2^10 kibi, 2^20 mebi, 2^30 gibi ...
- memory systems do not address single bits, they have an address space, range of addresses
- byte addressable systems refer to bytes or a word for instructions
- word addressable memory systems are rare, instructions don't have access to individual bytes, only words
- commonly, word length is 32 bits can be encoded for types of information (integers, ASCII or Unicode)
- byte ordering defines how addresses are assigned to bytes of a word
  - **big-endian** byte ordering assigns the lower byte address to more significant bytes within a word (more sequential)
  - **little-endian** is opposite (like how numbers are read)
- word alignment structures words 4 addresses apart

### Instruction Sets
- computer must have instructions capable of performing data transfers, arithmetic, sequence control, I/O
- an Instruction-set architecture (ISA) defines set of opcodes and native commands by a processor (ARM, x86, MIPS, SPARC, RISC-V)
- RISC ISA, each instruction fits in a word and memory operands are accessed only using load and store instructions
  - all operands for arithmetic and logical operations must be in processor registers
- CISC ISA has variable length for instructions, many instructions can access memory direction using memory addresses

### Representative Notations
- **Register Transfer Notation** is a way of expressing semantics of instructions as data transfers
  - memory locations are symbolic names like `LOC1`
  - Registers are identified by register names `R0`
  - contents of memory locations are denoted by placing square brackets `[LOC1]`
  - control signals are symbolic names `T1`
  - assignment statements transfer/manipulate data `R1 <- [LOC1]`
- **Assembly Language Notation** represents machine instructions and programs, to express operations, source and destination operands
  - `Load R1, LOC1` *load into R1 from LOC1*; `Add R2, R3, R4` *add R3 and R4 and save into R2*
  - `Subtract R2, R2, #1` = `R2 <- [R2]-1
  - `Branch_if_[R2]>0 LOOP` = `If(T1>0) where T <- [R2] then PC<-LOOP` used for looping until conditional
  - `Clear` = `R2 <- 0`

### Addressing Modes
- addressing modes different ways to specify the location of instruction operands
- *effective address* is the location of an operand, which differs based on the addressing mode
- Immediate `#Value`, Operand = Value
- Register `Ri`, EA = Ri where i is any integer and R is a keyword
- Absolute `LOC`, EA = `LOC` is exact address
- Register Indirect Addressing `(Ri)`, EA = `[Ri]` evaluates the value in the register (or mem location)
- Index addressing `X(Ri)`, EA = `[Ri] + X` is used when the operand address is a known constant offest from a known mem location, useful for arrays
- Base with index addressing `(Ri, Rj)`, EA = `[Ri] + [Rj]`, useful when index offset is non constant
  - PC-relative addressing is a special case of index addressing, where Ri = PC, useful for branching 
