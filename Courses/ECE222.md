# Digital Computers

# Part 3: ISA & Addressing Modes
### Intro to Addressing
- binary prefixes, 2^10 kibi, 2^20 mebi, 2^30 gibi ...
- memory systems do not address single bits, they have an address space, range of addresses
- byte addressable systems refer to bytes or a word for instructions
- word addressable memory systems are rare, instructions don't have access to individual bytes, only words
- commonly, word length is 32 bits can be encoded for types of information (integers, ASCII or Unicode)
- byte ordering defines how addresses are assigned to bytes of a word
  - **big-endian** byte ordering assigns the lower byte address to more significant bytes within a word (more sequential)
  - **little-endian** is opposite (like how numbers are read)
- word alignment structures words 4 addresses apart

### Instruction Sets
- computer must have instructions capable of performing data transfers, arithmetic, sequence control, I/O
- an Instruction-set architecture (ISA) defines set of opcodes and native commands by a processor (ARM, x86, MIPS, SPARC, RISC-V)
- RISC ISA, each instruction fits in a word and memory operands are accessed only using load and store instructions
  - all operands for arithmetic and logical operations must be in processor registers
- CISC ISA has variable length for instructions, many instructions can access memory direction using memory addresses

### Representative Notations
- **Register Transfer Notation** is a way of expressing semantics of instructions as data transfers
  - memory locations are symbolic names like `LOC1`
  - Registers are identified by register names `R0`
  - contents of memory locations are denoted by placing square brackets `[LOC1]`
  - control signals are symbolic names `T1`
  - assignment statements transfer/manipulate data `R1 <- [LOC1]`
- **Assembly Language Notation** represents machine instructions and programs, to express operations, source and destination operands
  - `Load R1, LOC1` *load into R1 from LOC1*
  - `Add R2, R3, R4` *add R3 and R4 and save into R2*
  - `Store R1, LOC1` is **BACKWARDS**, *store contents of R1 into LOC1*
  - `Subtract R2, R2, #1` = `R2 <- [R2]-1`
  - `Branch_if_[R2]>0 LOOP` = `If(T1>0) where T <- [R2] then PC<-LOOP` used for looping until conditional
  - `Clear` = `R2 <- 0`

### Addressing Modes
- addressing modes are different ways to specify the location of instruction's operand
- *effective address* is the location of an operand, which differs based on the addressing mode
- Immediate `#Value`, Operand = Value
- Register `Ri`, EA = Ri where i is any integer and R is a keyword
- Absolute/Memory Addressing `LOC`, EA = `LOC` is exact address
- Register Indirect Addressing `(Ri)`, EA = `[Ri]` evaluates the value in the register (or mem location)
- Index addressing `X(Ri)`, EA = `[Ri] + X` is used when the operand address is a known constant offest from a known mem location, useful for arrays
- Base with index addressing `(Ri, Rj)`, EA = `[Ri] + [Rj]`, useful when index offset is non constant
  - PC-relative addressing is a special case of index addressing, where Ri = PC, useful for branching 
- Auto increment addressing simplifies successive address loading: `(Ri)+`, EA = `[Ri]`; `increment Ri`
  - increment is dependent on addressing system (byte vs word), and post-increments
  - `Load R2, (R3)+` = `R2 <- [R3]; R3 <- [R3] + #4`
  - decrementing is similar, but it decrements prior to the register being read
  - both are useful for dealing with stacks a queues

### Stacks
- resides in main memory, top of stack is the lowest memory address, pointed to by the special CPU register called the stack pointer
- Push is `Subtract SP, SP, #4; Store R2, (SP)`, Pop is `Load R1, (SP); Add SP, SP, #4;`
- Subroutines are blocks of instructions that are executed repeatedly for modularization
  - invoked by executing a `Call` instruction, executes, returns to the main program by `Return` instruction
  - implemented by **subroutine linkage method**, stored on the stack or in a special register called the *link register*
  - a call is a special branch instruction that invokes a subroutine by storing contents of PC to the link register and branching to the new target address, then returns the PC to the value in the link register
- subroutines can be nested, so we need a way to store multiple link registers, which is done so on the stack (raises issues with stack overflows if full or errors if the stack is not properly maintained)
- subroutines can take parameters, passed through registers (by value), memory locations (by reference) or passed on the stack (global namespace)
- locations at the top of the processor stack is the *stack frame*, private namespace by subroutines
  - *frame pointer (FP) register* enables access ot private work space
  - stack frame consists of all items pushed onto the stack before or during the subroutine, including parameters and return address before and frame pointer, local variables and register values modified during the subroutine
  - the frame pointer indicates start of new stack frame where parameters are stored at `n(FP)` and local vars at `-n(FP)`, where n is a multiple of 4

# Part 4: ARM
### ARM ISA Characteristics
- Advanced RISC Machine is most common
- RISC has fixed length instructions, load and store instructions access memory, arithmetic/logic instructions operate only on registers
  - requires less transistors than CISC processors in personal computers
- has 16 registers, 15 general purpose and 1 program counter at R15
- CPSR (Current program status register) holds N-Negative, Z-Zero, C-Carry, V-Overflow, (conditional codes, all are set when event occurs else cleared) interupt disable, 5 status registers

#### Addressing Modes
- all addressing modes are derivatives of indexing addressing mode, where effective address is the sum of [Rn, #offset]
  - PC-relative: `LDR Rd, Item` is semantically `Rd <- [[PC] + Item]`
    - for ARM, processors are pipelined, by the time the load is executed, the next instruction has already been fetched so `[PC] = PC+8` pointing two instructions ahead of load 
  - Pre-index: `LDR Rd, [Rn, #offset]` is semantically `Rd <- [[Rn] + #offset]`
  - Pre-indexing with writeback: `LDR Rd, [Rn, #offset]!` is semantically `Rd <- [[Rn] + #offset]; Rn <- [Rn] + #offset`
    - can be used for easier iteration through sequential memory
  - post-index: `LDR Rd, [Rn], #offset` is semantically `Rd <- [[Rn]]; Rn <- [Rn] + offset`; increments index after loading

#### Memory Operations
- when loading with fewer than 32 bits, zero extensions are used to fill the rest of the word with 0s, signed extension fills with the most significant bit loaded into remaining bits
- Regular: LDR/STR for words, H suffix (LDRH) for half words (zero extended), B suffix for bytes (zero), SB/SH for sign extended versions
- Multiple word load/store: `LDMIA R10!, {R0, R1, R6, R7)`, IA is opcode for increment after, R10 holds the memory location to start loading from, and loads words sequentially into specified registers. IA makes R10 hold [R10] + 4*n for n registers

#### Instructions
All instructions can take registers or literals 
- `ADD R0, R2, R4`: R0 <- [R2] + [R4]
- `SUB R0, R3, #17`: R0 <- [R3] - 17
- shifts and rotates can be done on registers: (logical) LSL, LSR, (arithmetic) ASR, (rotate) ROR
  - arithmetic shifts preserve sign, logical shifts clear vacated bits
  - `ADD R0, R1, R2, LSL #4`: R0 <- [R1] + 2^4*[R2]
- `MOV R0, R1`: R0 <- [R1]
- `TST R0, R1`: bitwise AND of [R0] and [R1] and sets condition code Z, good for checking status bits
- `TEQ R0, R1`: Z = [R0] == [R1] ? 1 : 0
- `CMP R0, R1`: [R0] - [R1] and update condition code accordingly
- `B{Condition Suffix} LOC` for branching; see list of condition suffixes
  - conditional suffixes can be attached to other instructions too, executing based on CPSR flags (N,Z,V,C)
  - `CMP R0, R1; MOVLT R0, R1`: R0 <- R1 if R0 < R1

#### Assembler
Assembler converts source program to an object program in machine language
- `label operation operand(s) comment`
- operations can either be mnemonics, labels and names are in a symbol table
- assembler directives does stuff during translation:
  1. define constants
  2. reserve storage locations for data values
  3. initialize data values stored in memory 
  4. indicate where in memory a program should be located
- assembler directives depend on the specific assembler
  - AREA specifies start of CODE/DATA
  - ENTRY specifies start of program execution
  - DCD label and initialize data operands
  - EQU declares symbolic names for constants
  - RN assign COUNTER RN 3
- pseudo-instructions are accepted by assembler and are synthesized to actual instructions 
  - `LDR R0, =ADDRESS`: LDR R0, #0x127, for ADDRESS=0x127
- example: push/pop for stacks 
  - LDMIA => POP, STMDB => PUSH
- Subroutine Linkage with branch-and-link: `BL TARGET`
  - value of PC is store in R14, which is the link register (LR) for returning after a subroutine
  - branch to TARGET 
- multiple passes are necessary for assembly because of forward references
- two-pass assembly first generates symbol table, then substitute values in labels
- linkers and loaders allow multiple modules to assemble into one binary
  - each module is assembled relative to location 0, then linker adds appropriate offset once code location is determined for each module
  - relative addressing and some instructions are position independent, while referencing external labels are position dependent
  
# Part 5: Basic IO 
A system bus is an example of an interconnection network, joining I/O devices, memory devices and CPU
- memory mapped I/O treats I/O devices as part of the address space 
  - allows us to apply memory instructions for I/O
- I/O device interface is a circuit between a device and the interconnection network
  - provides means for data transfer (DATA register) and status (STATUS REGISTER) and control (CONTROL register) information
- program controlled I/O and interrupt-driven I/O use memory mapped I/O

### Program Controlled I/O
- program-controlled I/O, I/O interaction is realized by a program, through an interface listening for input
