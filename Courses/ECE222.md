### Addressing Modes
- binary prefixes, 2^10 kibi, 2^20 mebi, 2^30 gibi ...
- memory systems do not address single bits, they have an address space, range of addresses
- byte addressable systems refer to bytes or a word for instructions
- word addressable memory systems are rare, instructions don't have access to individual bytes, only words
- commonly, word length is 32 bits can be encoded for types of information (integers, ASCII or Unicode)
- byte ordering defines how addresses are assigned to bytes of a word
  - **big-endian** byte ordering assigns the lower byte address to more significant bytes within a word (more sequential)
  - *little-endian** is opposite (like how numbers are read)
- word alignment structures words 4 addresses apart

### Instruction Sets
- computer must have instructions capable of performing data transfers, arithmetic, sequence control, I/O
- an Instruction-set architecture (ISA) defines set of opcodes and native commands by a processor (ARM, x86, MIPS, SPARC, RISC-V)
- RISC ISA, each instruction fits in a word and memory operands are accessed only using load and store instructions
  - all operands for arithmetic and logical operations must be in processor registers
- CISC ISA has variable length for instructions, many instructions can access memory direction using memory addresses

### Representative Notations
- Register Transfer Notation is a way of expressing semantics of instructions as data transfers
  - memory locations are symbolic names like `LOC1`
  - Registers are identified by register names `R0`
  - contents of memory locations are denoted by placing square brackets `[LOC1]`
  - control signals are symbolic names `T1`
  - assignment statements transfer/manipulate data `R1 <- [LOC1]`
- Assembly Language Notation represents machine instructions and programs, to express operations, source and destination operands
  - `Load R1, LOC1` *load into R1 from LOC1*; `Add R2, R3, R4` *add R3 and R4 and save into R2*
  - `Subtract R2, R2, #1` = `R2 <- [R2]-1, `Branch_if_[R2]>0 LOOP` = `If(T1>0) where T <- [R2] then PC<-LOOP`, `Clear` = `R2 <- 0`
