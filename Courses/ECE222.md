# Digital Computers

# Part 3: ISA & Addressing Modes
### Intro to Addressing
- binary prefixes, 2^10 kibi, 2^20 mebi, 2^30 gibi ...
- memory systems do not address single bits, they have an address space, range of addresses
- byte addressable systems refer to bytes or a word for instructions
- word addressable memory systems are rare, instructions don't have access to individual bytes, only words
- commonly, word length is 32 bits can be encoded for types of information (integers, ASCII or Unicode)
- byte ordering defines how addresses are assigned to bytes of a word
  - **big-endian** byte ordering assigns the lower byte address to more significant bytes within a word (more sequential)
  - **little-endian** is opposite (like how numbers are read)
- word alignment structures words 4 addresses apart

### Instruction Sets
- computer must have instructions capable of performing data transfers, arithmetic, sequence control, I/O
- an Instruction-set architecture (ISA) defines set of opcodes and native commands by a processor (ARM, x86, MIPS, SPARC, RISC-V)
- RISC ISA, each instruction fits in a word and memory operands are accessed only using load and store instructions
  - all operands for arithmetic and logical operations must be in processor registers
- CISC ISA has variable length for instructions, many instructions can access memory direction using memory addresses

### Representative Notations
- **Register Transfer Notation** is a way of expressing semantics of instructions as data transfers
  - memory locations are symbolic names like `LOC1`
  - Registers are identified by register names `R0`
  - contents of memory locations are denoted by placing square brackets `[LOC1]`
  - control signals are symbolic names `T1`
  - assignment statements transfer/manipulate data `R1 <- [LOC1]`
- **Assembly Language Notation** represents machine instructions and programs, to express operations, source and destination operands
  - `Load R1, LOC1` *load into R1 from LOC1*
  - `Add R2, R3, R4` *add R3 and R4 and save into R2*
  - `Store R1, LOC1` is **BACKWARDS**, *store contents of R1 into LOC1*
  - `Subtract R2, R2, #1` = `R2 <- [R2]-1
  - `Branch_if_[R2]>0 LOOP` = `If(T1>0) where T <- [R2] then PC<-LOOP` used for looping until conditional
  - `Clear` = `R2 <- 0`

### Addressing Modes
- addressing modes are different ways to specify the location of instruction's operand
- *effective address* is the location of an operand, which differs based on the addressing mode
- Immediate `#Value`, Operand = Value
- Register `Ri`, EA = Ri where i is any integer and R is a keyword
- Absolute/Memory Addressing `LOC`, EA = `LOC` is exact address
- Register Indirect Addressing `(Ri)`, EA = `[Ri]` evaluates the value in the register (or mem location)
- Index addressing `X(Ri)`, EA = `[Ri] + X` is used when the operand address is a known constant offest from a known mem location, useful for arrays
- Base with index addressing `(Ri, Rj)`, EA = `[Ri] + [Rj]`, useful when index offset is non constant
  - PC-relative addressing is a special case of index addressing, where Ri = PC, useful for branching 
- Auto increment addressing simplifies successive address loading: `(Ri)+`, EA = `[Ri]`; `increment Ri`
  - increment is dependent on addressing system (byte vs word), and post-increments
  - `Load R2, (R3)+` = `R2 <- [R3]; R3 <- [R3] + #4`
  - decrementing is similar, but it decrements prior to the register being read
  - both are useful for dealing with stacks a queues

### Stacks
- resides in main memory, top of stack is the lowest memory address, pointed to by the special CPU register called the stack pointer
- Push is `Subtract SP, SP, #4; Store R2, (SP)`, Pop is `Load R1, (SP); Add SP, SP, #4;`
- Subroutines are blocks of instructions that are executed repeatedly for modularization
  - invoked by executing a `Call` instruction, executes, returns to the main program by `Return` instruction
  - implemented by **subroutine linkage method**, stored on the stack or in a special register called the *link register*
  - a call is a special branch instruction that invokes a subroutine by storing contents of PC to the link register and branching to the new target address, then returns the PC to the value in the link register
- subroutines can be nested, so we need a way to store multiple link registers, which is done so on the stack (raises issues with stack overflows if full or errors if the stack is not properly maintained)
- subroutines can take parameters, passed through registers (by value), memory locations (by reference) or passed on the stack (global namespace)
- continue at slide 56
